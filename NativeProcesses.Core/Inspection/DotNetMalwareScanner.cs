/*
   NativeProcesses Framework  |
   © 2025 Selahattin Erkoc
   Licensed under GNU GPL v3  |  https://www.gnu.org/licenses/
*/
using Microsoft.Diagnostics.Runtime;
using System;
using System.Collections.Generic;
using System.Linq;
using NativeProcesses.Core.Engine;
using System.Text;
using System.IO;
using NativeProcesses.Core.Native;

namespace NativeProcesses.Core.Inspection
{
    public class DotNetMalwareScanner
    {
        private readonly IEngineLogger _logger;

        public DotNetMalwareScanner(IEngineLogger logger)
        {
            _logger = logger;
        }
        // In NativeProcesses.Core.Inspection.DotNetMalwareScanner.cs

        public List<PeAnomalyInfo> Scan(int pid)
        {
            var anomalies = new List<PeAnomalyInfo>();
            DataTarget target = null;
            string dumpPath = null;

            try
            {
                // SCHRITT A: Stealth Dump erstellen
                // Wir lagern den Speicher auf die Platte aus, um ihn sicher zu analysieren
                dumpPath = SnapshotDumper.CreateSafeDump(pid, _logger);

                if (string.IsNullOrEmpty(dumpPath))
                {
                    _logger?.Log(LogLevel.Warning, "Could not create memory dump. Falling back to live attach (RISKY).");
                    target = DataTarget.AttachToProcess(pid, false); // Fallback
                }
                else
                {
                    // SCHRITT B: Dump laden (Viel sicherer, kein Freeze, kein Debugger-Flag im Ziel)
                    target = DataTarget.LoadDump(dumpPath);
                }

                // ... (Ab hier bleibt dein Code fast gleich) ...

                if (target.ClrVersions.Length == 0) return anomalies;

                // ClrMD Logik
                var runtime = target.ClrVersions[0].CreateRuntime();
                var heap = runtime.Heap;

                if (!heap.CanWalkHeap)
                {
                    // Bei einem Dump sollte der Heap IMMER walk-able sein, 
                    // da der Snapshot einen konsistenten Zustand garantiert!
                    _logger?.Log(LogLevel.Warning, "Heap not walkable (unexpected in dump).");
                    return anomalies;
                }

                // Deine bestehenden Checks aufrufen...
                CheckForFloatingAssemblies(runtime, anomalies);
                CheckForSuspiciousObjects(heap, anomalies);
                CheckForPowerShellHosting(runtime, anomalies);
                CheckForSuspiciousHeapArrays(heap, anomalies);
                CheckForObfuscatedModules(runtime, anomalies);
            }
            catch (Exception ex)
            {
                _logger?.Log(LogLevel.Debug, $"DotNetMalwareScanner failed for PID {pid}", ex);
            }
            finally
            {
                target?.Dispose();

                // SCHRITT C: Aufräumen
                if (!string.IsNullOrEmpty(dumpPath) && File.Exists(dumpPath))
                {
                    try { File.Delete(dumpPath); } catch { }
                }
            }

            return anomalies;
        }
        //public List<PeAnomalyInfo> Scan(int pid)
        //{
        //    var anomalies = new List<PeAnomalyInfo>();
        //    DataTarget target = null;

        //    try
        //    {
        //        // ClrMD 2.0+: AttachToProcess gibt direkt das DataTarget zurück
        //        target = DataTarget.AttachToProcess(pid, false);

        //        // FIX 1: ClrVersions ist ein Array -> Length nutzen statt Count (Method Group Fehler)
        //        if (target.ClrVersions.Length == 0) return anomalies;

        //        var runtime = target.ClrVersions[0].CreateRuntime();
        //        var heap = runtime.Heap;

        //        if (!heap.CanWalkHeap)
        //        {
        //            _logger?.Log(LogLevel.Warning, $"DotNetMalwareScanner: Heap not walkable for PID {pid}");
        //            return anomalies;
        //        }

        //        CheckForFloatingAssemblies(runtime, anomalies);
        //        CheckForSuspiciousObjects(heap, anomalies);
        //        CheckForPowerShellHosting(runtime, anomalies);

        //        // Scan nach Byte-Arrays (Loaders)
        //        CheckForSuspiciousHeapArrays(heap, anomalies);

        //        // Scan nach Obfuscation
        //        CheckForObfuscatedModules(runtime, anomalies);
        //    }
        //    catch (Exception ex)
        //    {
        //        _logger?.Log(LogLevel.Debug, $"DotNetMalwareScanner failed for PID {pid}", ex);
        //    }
        //    finally
        //    {
        //        target?.Dispose();
        //    }

        //    return anomalies;
        //}

        private void CheckForSuspiciousHeapArrays(ClrHeap heap, List<PeAnomalyInfo> anomalies)
        {
            // Wir benötigen den DataReader für Speicherzugriffe
            var dataReader = heap.Runtime.DataTarget.DataReader;
            int pointerSize = dataReader.PointerSize;

            foreach (var obj in heap.EnumerateObjects())
            {
                if (obj.Type == null || !obj.IsArray || obj.Type.Name != "System.Byte[]")
                    continue;

                int length = obj.AsArray().Length;
                if (length < 20480) continue; // Nur große Arrays (>20KB) prüfen

                // FIX 2: ClrHeap hat kein ReadMemory. Wir nutzen den DataReader.
                // Offset zu den Daten im Array: MethodTable (PtrSize) + Length (4 Bytes)
                ulong dataOffset = (ulong)pointerSize + 4;
                ulong dataAddress = obj.Address + dataOffset;

                byte[] rawData = new byte[512];
                // FIX: DataReader.Read nutzt Span<byte>
                int bytesRead = dataReader.Read(dataAddress, new Span<byte>(rawData));

                if (bytesRead > 0)
                {
                    // Suche nach PE-Header (MZ)
                    if (ContainsPeHeader(rawData))
                    {
                        anomalies.Add(new PeAnomalyInfo
                        {
                            ModuleName = ".NET Heap",
                            AnomalyType = "Decrypted PE File in Memory",
                            Details = $"Found byte[] array of size {length:N0} containing a PE Header (MZ). This is a raw executable/DLL waiting to be injected (Reflective DLL / RunPE).",
                            Severity = "Critical"
                        });
                        // Ein Fund pro Array reicht
                        continue;
                    }
                }
            }
        }

        private void CheckForObfuscatedModules(ClrRuntime runtime, List<PeAnomalyInfo> anomalies)
        {
            // FIX 3: Modules ist keine Property -> EnumerateModules() nutzen
            foreach (var module in runtime.EnumerateModules())
            {
                // FIX 4: FileName existiert nicht, wir nutzen Name (kann auch AssemblyName sein)
                string name = module.Name;
                if (string.IsNullOrEmpty(name)) continue;

                string fileName = System.IO.Path.GetFileName(name);
                bool isSuspiciousName = false;

                if (fileName.Any(c => c < 32 || (c > 126 && c < 160)))
                {
                    isSuspiciousName = true;
                }

                if (fileName.Length < 3 && !fileName.EndsWith(".dll") && !fileName.EndsWith(".exe"))
                {
                    isSuspiciousName = true;
                }

                if (fileName.Contains("Confused") || fileName.Contains("Reactor") || fileName.Contains("Eazfuscator"))
                {
                    isSuspiciousName = true;
                }

                if (isSuspiciousName)
                {
                    if (fileName.StartsWith("System") || fileName.StartsWith("Microsoft") || fileName.Contains("mscorlib"))
                        continue;

                    anomalies.Add(new PeAnomalyInfo
                    {
                        ModuleName = name,
                        AnomalyType = "Obfuscated Module Name",
                        Details = $"Module name '{fileName}' looks suspicious/obfuscated.",
                        Severity = "Medium"
                    });
                }
            }
        }

        private bool ContainsPeHeader(byte[] buffer)
        {
            for (int i = 0; i < buffer.Length - 2; i++)
            {
                if (buffer[i] == 0x4D && buffer[i + 1] == 0x5A) // MZ
                {
                    return true;
                }
            }
            return false;
        }

        private void CheckForFloatingAssemblies(ClrRuntime runtime, List<PeAnomalyInfo> anomalies)
        {
            // FIX: EnumerateModules() statt Modules
            foreach (var module in runtime.EnumerateModules())
            {
                bool isSuspicious = false;
                string reason = "";

                // FIX 5: Ersatz für string.IsNullOrEmpty(module.FileName).
                // Wir prüfen auf "Flat" Layout. Das ist der sicherste Indikator für Assembly.Load(byte[]).
                // "Mapped" bedeutet von Disk geladen. "Flat" bedeutet aus dem Speicher.
                if (module.Layout == ModuleLayout.Flat && !module.IsDynamic)
                {
                    isSuspicious = true;
                    reason = "Module has Flat Layout (Loaded via Assembly.Load(byte[]) / Reflection).";
                }
                else if (module.IsDynamic)
                {
                    if (module.Name != null && !module.Name.Contains("Anonymously Hosted DynamicMethods") && !module.Name.Contains("Workflow"))
                    {
                        isSuspicious = true;
                        reason = "Suspicious Dynamic Module detected.";
                    }
                }

                if (isSuspicious)
                {
                    anomalies.Add(new PeAnomalyInfo
                    {
                        ModuleName = module.Name ?? "Unknown_Assembly",
                        AnomalyType = ".NET Reflected Assembly",
                        Details = $"{reason} Base: 0x{module.ImageBase:X}. Indicator for unpacked malware.",
                        Severity = "Critical"
                    });
                }
            }
        }

        private void CheckForSuspiciousObjects(ClrHeap heap, List<PeAnomalyInfo> anomalies)
        {
            int webClientCount = 0;
            int cryptoCount = 0;
            bool stealerArtifactFound = false;
            bool nanoCoreFound = false;
            bool confuserFound = false;

            foreach (var obj in heap.EnumerateObjects())
            {
                if (obj.Type == null) continue;
                string name = obj.Type.Name;

                if (string.IsNullOrEmpty(name)) continue;

                if (name == "System.Net.WebClient" || name == "System.Net.Http.HttpClient")
                {
                    webClientCount++;
                }
                else if (name.Contains("System.Security.Cryptography.Aes") ||
                         name.Contains("RijndaelManaged") ||
                         name.Contains("DESCryptoServiceProvider"))
                {
                    cryptoCount++;
                }
                else if (!stealerArtifactFound)
                {
                    if (name.IndexOf("Credentials", StringComparison.OrdinalIgnoreCase) >= 0 ||
                        name.IndexOf("Recovery", StringComparison.OrdinalIgnoreCase) >= 0 ||
                        name.IndexOf("Stealer", StringComparison.OrdinalIgnoreCase) >= 0 ||
                        name.IndexOf("PassRecovery", StringComparison.OrdinalIgnoreCase) >= 0 ||
                        name.IndexOf("AccountGrabber", StringComparison.OrdinalIgnoreCase) >= 0)
                    {
                        if (!name.StartsWith("System.") && !name.StartsWith("Microsoft."))
                        {
                            anomalies.Add(new PeAnomalyInfo
                            {
                                ModuleName = ".NET Heap",
                                AnomalyType = "InfoStealer Artifact (AgentTesla/RedLine)",
                                Details = $"Suspicious class found on heap: '{name}'.",
                                Severity = "High"
                            });
                            stealerArtifactFound = true;
                        }
                    }
                }
                else if (!nanoCoreFound)
                {
                    if (name.StartsWith("Client.Network") ||
                        name.Contains("NanoCore") ||
                        name.Contains("IClientNetwork"))
                    {
                        anomalies.Add(new PeAnomalyInfo
                        {
                            ModuleName = ".NET Heap",
                            AnomalyType = "NanoCore RAT Detection",
                            Details = $"NanoCore signature found in heap object: '{name}'",
                            Severity = "Critical"
                        });
                        nanoCoreFound = true;
                    }
                }
                else if (!confuserFound)
                {
                    if (name.Contains("ConfusedByAttribute") || name.Contains("Confuser"))
                    {
                        anomalies.Add(new PeAnomalyInfo
                        {
                            ModuleName = ".NET Heap",
                            AnomalyType = "Obfuscator Detected",
                            Details = $"Found object specific to ConfuserEx/Obfuscator: {name}",
                            Severity = "Medium"
                        });
                        confuserFound = true;
                    }
                }
            }

            if (webClientCount > 0)
            {
                anomalies.Add(new PeAnomalyInfo
                {
                    ModuleName = ".NET Heap",
                    AnomalyType = "Downloader Activity",
                    Details = $"Found {webClientCount} WebClient/HttpClient instances.",
                    Severity = "Medium"
                });
            }

            if (cryptoCount > 5)
            {
                anomalies.Add(new PeAnomalyInfo
                {
                    ModuleName = ".NET Heap",
                    AnomalyType = "High Crypto Activity",
                    Details = $"Found {cryptoCount} crypto objects (AES/Rijndael).",
                    Severity = "High"
                });
            }
        }

        private void CheckForPowerShellHosting(ClrRuntime runtime, List<PeAnomalyInfo> anomalies)
        {
            // FIX 6: EnumerateModules() nutzen
            bool psLoaded = runtime.EnumerateModules().Any(m =>
                (m.Name != null && m.Name.IndexOf("System.Management.Automation", StringComparison.OrdinalIgnoreCase) >= 0));

            if (psLoaded)
            {
                anomalies.Add(new PeAnomalyInfo
                {
                    ModuleName = "System.Management.Automation.dll",
                    AnomalyType = "PowerShell Hosting (LOLBin)",
                    Details = "Process is hosting the PowerShell engine.",
                    Severity = "Critical"
                });
            }
        }
    }
}