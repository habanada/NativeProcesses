/*
   NativeProcesses Framework  |  © 2025 Selahattin Erkoc
   Licensed under GNU GPL v3  |  https://www.gnu.org/licenses/
*/
using Microsoft.Diagnostics.Runtime;
using System;
using System.Collections.Generic;
using System.Linq;
using NativeProcesses.Core.Engine;
using System.Text;
using System.IO;
using NativeProcesses.Core.Native;

namespace NativeProcesses.Core.Inspection
{
    public class DotNetMalwareScanner
    {
        private readonly IEngineLogger _logger;

        public DotNetMalwareScanner(IEngineLogger logger)
        {
            _logger = logger;
        }

        public List<PeAnomalyInfo> Scan(int pid)
        {
            var anomalies = new List<PeAnomalyInfo>();
            DataTarget target = null;
            string dumpPath = null;

            try
            {
                // SCHRITT A: Stealth Dump erstellen
                // Wir lagern den Speicher auf die Platte aus, um ihn sicher zu analysieren (Snapshot/Freeze)
                dumpPath = SnapshotDumper.CreateSafeDump(pid, _logger);

                if (string.IsNullOrEmpty(dumpPath))
                {
                    _logger?.Log(LogLevel.Warning, "Could not create memory dump. Falling back to live attach (RISKY).");
                    target = DataTarget.AttachToProcess(pid, false); // Fallback
                }
                else
                {
                    // SCHRITT B: Dump laden (Sicherer, kein Freeze, kein Debugger-Flag im Ziel)
                    target = DataTarget.LoadDump(dumpPath);
                }

                if (target.ClrVersions.Length == 0) return anomalies;

                // ClrMD Logik
                var runtime = target.ClrVersions[0].CreateRuntime();
                var heap = runtime.Heap;

                if (!heap.CanWalkHeap)
                {
                    _logger?.Log(LogLevel.Warning, "Heap not walkable (unexpected in dump).");
                    return anomalies;
                }

                // Die Checks ausführen
                CheckForFloatingAssemblies(runtime, anomalies);
                CheckForSuspiciousObjects(heap, anomalies);
                CheckForPowerShellHosting(runtime, anomalies);
                CheckForSuspiciousHeapArrays(heap, anomalies); // <- Hier ist das große Upgrade
                CheckForObfuscatedModules(runtime, anomalies);
            }
            catch (Exception ex)
            {
                _logger?.Log(LogLevel.Debug, $"DotNetMalwareScanner failed for PID {pid}", ex);
            }
            finally
            {
                target?.Dispose();

                // SCHRITT C: Aufräumen
                if (!string.IsNullOrEmpty(dumpPath) && File.Exists(dumpPath))
                {
                    try { File.Delete(dumpPath); } catch { }
                }
            }

            return anomalies;
        }

        /// <summary>
        /// Untersucht byte[] Arrays im Heap auf versteckte PE-Dateien oder Shellcode.
        /// </summary>
        private void CheckForSuspiciousHeapArrays(ClrHeap heap, List<PeAnomalyInfo> anomalies)
        {
            // Wir benötigen den DataReader für Speicherzugriffe
            var dataReader = heap.Runtime.DataTarget.DataReader;
            int pointerSize = dataReader.PointerSize;

            // Performance: Wir begrenzen die Anzahl der Funde pro Kategorie, um Logs nicht zu fluten
            int shellcodeCount = 0;
            int peFileCount = 0;

            foreach (var obj in heap.EnumerateObjects())
            {
                if (obj.Type == null || !obj.IsArray || obj.Type.Name != "System.Byte[]")
                    continue;

                int length = obj.AsArray().Length;

                // Filter: Zu kleine Arrays ignorieren (Shellcode ist selten < 64 bytes, PE Files nie < 512)
                // Wir setzen die Grenze auf 1KB, um kleine Buffer zu ignorieren und CPU zu sparen.
                if (length < 1024) continue;

                // Offset zu den Daten im Array: MethodTable (PtrSize) + Length (4 Bytes)
                ulong dataOffset = (ulong)pointerSize + 4;
                ulong dataAddress = obj.Address + dataOffset;

                // Wir lesen max 4KB für die Analyse (genug für Header und Shellcode Signaturen)
                int bytesToRead = Math.Min(length, 4096);
                byte[] rawData = new byte[bytesToRead];

                int bytesRead = dataReader.Read(dataAddress, new Span<byte>(rawData));

                if (bytesRead > 0)
                {
                    // CHECK 1: Suche nach PE-Header (MZ) -> Reflective DLL / RunPE
                    if (peFileCount < 5 && ContainsPeHeader(rawData))
                    {
                        anomalies.Add(new PeAnomalyInfo
                        {
                            ModuleName = ".NET Heap",
                            AnomalyType = "Decrypted PE File in Memory",
                            Details = $"Found byte[] array of size {length:N0} containing a PE Header (MZ). This is a raw executable/DLL waiting to be injected.",
                            Severity = "Critical"
                        });
                        peFileCount++;
                        continue; // Wenn es ein PE ist, ist es kein Shellcode (bzw. höherwertig)
                    }

                    // CHECK 2: Suche nach Shellcode (NEU: via ShellcodeDetector)
                    if (shellcodeCount < 5)
                    {
                        if (ShellcodeDetector.IsLikelyShellcode(rawData, out string reason))
                        {
                            if (reason != "Clean")
                            {
                                string severity = reason.Contains("High Entropy") ? "High" : "Critical";

                                anomalies.Add(new PeAnomalyInfo
                                {
                                    ModuleName = ".NET Heap",
                                    AnomalyType = "Malicious Code/Data in Heap",
                                    Details = $"Found suspicious byte[] array (Size: {length:N0}). Detection: {reason}",
                                    Severity = severity
                                });
                                shellcodeCount++;
                            }
                        }
                    }
                }
            }
        }

        private void CheckForObfuscatedModules(ClrRuntime runtime, List<PeAnomalyInfo> anomalies)
        {
            foreach (var module in runtime.EnumerateModules())
            {
                string name = module.Name;
                if (string.IsNullOrEmpty(name)) continue;

                string fileName = System.IO.Path.GetFileName(name);
                bool isSuspiciousName = false;

                // Check 1: Nicht-druckbare Zeichen im Namen
                if (fileName.Any(c => c < 32 || (c > 126 && c < 160)))
                {
                    isSuspiciousName = true;
                }

                // Check 2: Zufällige kurze Namen ohne Extension (außer System)
                if (fileName.Length < 5 && !fileName.EndsWith(".dll") && !fileName.EndsWith(".exe"))
                {
                    isSuspiciousName = true;
                }

                // Check 3: Bekannte Obfuscatoren
                if (fileName.Contains("Confused") || fileName.Contains("Reactor") || fileName.Contains("Eazfuscator"))
                {
                    isSuspiciousName = true;
                }

                if (isSuspiciousName)
                {
                    if (fileName.StartsWith("System") || fileName.StartsWith("Microsoft") || fileName.Contains("mscorlib"))
                        continue;

                    anomalies.Add(new PeAnomalyInfo
                    {
                        ModuleName = name,
                        AnomalyType = "Obfuscated Module Name",
                        Details = $"Module name '{fileName}' looks suspicious/obfuscated.",
                        Severity = "Medium"
                    });
                }
            }
        }

        private bool ContainsPeHeader(byte[] buffer)
        {
            if (buffer.Length < 2) return false;
            return (buffer[0] == 0x4D && buffer[1] == 0x5A); // MZ
        }

        private void CheckForFloatingAssemblies(ClrRuntime runtime, List<PeAnomalyInfo> anomalies)
        {
            foreach (var module in runtime.EnumerateModules())
            {
                bool isSuspicious = false;
                string reason = "";

                // "Flat" Layout ist der sicherste Indikator für Assembly.Load(byte[])
                if (module.Layout == ModuleLayout.Flat && !module.IsDynamic)
                {
                    isSuspicious = true;
                    reason = "Module has Flat Layout (Loaded via Assembly.Load(byte[]) / Reflection).";
                }
                else if (module.IsDynamic)
                {
                    // Filter für legitime dynamische Methoden (WPF, XML Serializer etc.)
                    if (module.Name != null &&
                        !module.Name.Contains("Anonymously Hosted DynamicMethods") &&
                        !module.Name.Contains("Workflow") &&
                        !module.Name.Contains("System.Xml"))
                    {
                        isSuspicious = true;
                        reason = "Suspicious Dynamic Module detected.";
                    }
                }

                if (isSuspicious)
                {
                    anomalies.Add(new PeAnomalyInfo
                    {
                        ModuleName = module.Name ?? "Unknown_Assembly",
                        AnomalyType = ".NET Reflected Assembly",
                        Details = $"{reason} Base: 0x{module.ImageBase:X}. Indicator for unpacked malware payload.",
                        Severity = "Critical"
                    });
                }
            }
        }

        private void CheckForSuspiciousObjects(ClrHeap heap, List<PeAnomalyInfo> anomalies)
        {
            int webClientCount = 0;
            int cryptoCount = 0;
            bool stealerArtifactFound = false;
            bool nanoCoreFound = false;
            bool confuserFound = false;

            foreach (var obj in heap.EnumerateObjects())
            {
                if (obj.Type == null) continue;
                string name = obj.Type.Name;

                if (string.IsNullOrEmpty(name)) continue;

                if (name == "System.Net.WebClient" || name == "System.Net.Http.HttpClient")
                {
                    webClientCount++;
                }
                else if (name.Contains("System.Security.Cryptography.Aes") ||
                         name.Contains("RijndaelManaged") ||
                         name.Contains("DESCryptoServiceProvider"))
                {
                    cryptoCount++;
                }
                else if (!stealerArtifactFound)
                {
                    if (name.IndexOf("Credentials", StringComparison.OrdinalIgnoreCase) >= 0 ||
                        name.IndexOf("Recovery", StringComparison.OrdinalIgnoreCase) >= 0 ||
                        name.IndexOf("Stealer", StringComparison.OrdinalIgnoreCase) >= 0 ||
                        name.IndexOf("PassRecovery", StringComparison.OrdinalIgnoreCase) >= 0 ||
                        name.IndexOf("AccountGrabber", StringComparison.OrdinalIgnoreCase) >= 0)
                    {
                        if (!name.StartsWith("System.") && !name.StartsWith("Microsoft."))
                        {
                            anomalies.Add(new PeAnomalyInfo
                            {
                                ModuleName = ".NET Heap",
                                AnomalyType = "InfoStealer Artifact (AgentTesla/RedLine)",
                                Details = $"Suspicious class found on heap: '{name}'.",
                                Severity = "High"
                            });
                            stealerArtifactFound = true;
                        }
                    }
                }
                else if (!nanoCoreFound)
                {
                    if (name.StartsWith("Client.Network") ||
                        name.Contains("NanoCore") ||
                        name.Contains("IClientNetwork"))
                    {
                        anomalies.Add(new PeAnomalyInfo
                        {
                            ModuleName = ".NET Heap",
                            AnomalyType = "NanoCore RAT Detection",
                            Details = $"NanoCore signature found in heap object: '{name}'",
                            Severity = "Critical"
                        });
                        nanoCoreFound = true;
                    }
                }
                else if (!confuserFound)
                {
                    if (name.Contains("ConfusedByAttribute") || name.Contains("Confuser"))
                    {
                        anomalies.Add(new PeAnomalyInfo
                        {
                            ModuleName = ".NET Heap",
                            AnomalyType = "Obfuscator Detected",
                            Details = $"Found object specific to ConfuserEx/Obfuscator: {name}",
                            Severity = "Medium"
                        });
                        confuserFound = true;
                    }
                }
            }

            if (webClientCount > 0)
            {
                // Info Level, da WebClients auch legitim sein können.
                anomalies.Add(new PeAnomalyInfo
                {
                    ModuleName = ".NET Heap",
                    AnomalyType = "Downloader Activity",
                    Details = $"Found {webClientCount} WebClient/HttpClient instances.",
                    Severity = "Low"
                });
            }

            if (cryptoCount > 5)
            {
                anomalies.Add(new PeAnomalyInfo
                {
                    ModuleName = ".NET Heap",
                    AnomalyType = "High Crypto Activity",
                    Details = $"Found {cryptoCount} crypto objects (AES/Rijndael).",
                    Severity = "Medium"
                });
            }
        }

        private void CheckForPowerShellHosting(ClrRuntime runtime, List<PeAnomalyInfo> anomalies)
        {
            bool psLoaded = runtime.EnumerateModules().Any(m =>
                (m.Name != null && m.Name.IndexOf("System.Management.Automation", StringComparison.OrdinalIgnoreCase) >= 0));

            if (psLoaded)
            {
                anomalies.Add(new PeAnomalyInfo
                {
                    ModuleName = "System.Management.Automation.dll",
                    AnomalyType = "PowerShell Hosting (LOLBin)",
                    Details = "Process is hosting the PowerShell engine. This is often used by malware to run scripts in memory.",
                    Severity = "Critical"
                });
            }
        }
    }
}