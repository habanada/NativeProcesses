/*
   NativeProcesses Framework  |
   © 2025 Selahattin Erkoc
   Licensed under GNU GPL v3  |  https://www.gnu.org/licenses/
*/
using System;
using System.Text;
using NativeProcesses.Core.Native;
using System.Runtime.InteropServices;

namespace NativeProcesses.Core.Inspection
{
    public class DetectedMalwareInfo
    {
        public string FamilyName { get; set; }
        public string Variant { get; set; }
        public IntPtr Address { get; set; }
        public string Details { get; set; }
    }

    public static class MalwareFamilyDetector
    {
        // Signaturen aus isfb_header.h
        private const uint ISFB_MJ_MAGIC = 0x4A4D; // "MJ"
        private const uint ISFB_J1_MAGIC = 0x314A; // "J1"
        private const uint ISFB_S1_MAGIC = 0x3153; // "S1"

        [StructLayout(LayoutKind.Sequential, Pack = 1)]
        private struct ISFB_HDR_MJ
        {
            public ushort Magic;      // "MJ"
            public ushort MachineId;  // Architecture
            public uint SizeOfImage;
            public uint SizeOfHeader;
            public uint CheckSum;
            public uint BuildId;      // Config ID / Date
        }

        public static DetectedMalwareInfo ScanMemoryBlock(byte[] buffer, IntPtr baseAddress)
        {
            if (buffer.Length < 1024) return null;

            // 1. ISFB (Ursnif) Check
            // ISFB nutzt oft eigene Header am Anfang des Memory Blocks, statt "MZ".

            // Check auf "MJ" (Magic Bytes)
            ushort magic = BitConverter.ToUInt16(buffer, 0);

            if (magic == ISFB_MJ_MAGIC)
            {
                // Validierung: Ist die Struktur plausibel?
                if (buffer.Length >= Marshal.SizeOf(typeof(ISFB_HDR_MJ)))
                {
                    var header = ByteArrayToStructure<ISFB_HDR_MJ>(buffer);

                    // Plausibilitätscheck: Headergröße muss kleiner als Imagegröße sein
                    if (header.SizeOfHeader > 0 && header.SizeOfHeader < header.SizeOfImage)
                    {
                        return new DetectedMalwareInfo
                        {
                            FamilyName = "ISFB / Ursnif",
                            Variant = "MJ Format",
                            Address = baseAddress,
                            Details = $"BuildID: {header.BuildId}, ImageSize: {header.SizeOfImage}"
                        };
                    }
                }
            }
            else if (magic == ISFB_J1_MAGIC)
            {
                return new DetectedMalwareInfo
                {
                    FamilyName = "ISFB / Ursnif",
                    Variant = "J1 Format (Packed)",
                    Address = baseAddress,
                    Details = "Detected proprietary J1 header used by newer Ursnif variants."
                };
            }
            else if (magic == ISFB_S1_MAGIC)
            {
                return new DetectedMalwareInfo
                {
                    FamilyName = "ISFB / Ursnif",
                    Variant = "S1 Format",
                    Address = baseAddress,
                    Details = "Detected proprietary S1 header."
                };
            }

            // 2. IcedID Check (Heuristik aus iceid_to_pe.cpp)
            // IcedID hat oft einen PE-Header (NT Sig), aber NULLEN anstatt MZ.
            // Das haben wir zwar im PeAnomalyScanner schon allgemein, aber hier klassifizieren wir es.
            if (buffer[0] == 0 && buffer[1] == 0) // Kein MZ
            {
                // Suche nach PE Signatur in den ersten 512 Bytes
                for (int i = 0; i < Math.Min(buffer.Length - 4, 512); i += 4)
                {
                    if (buffer[i] == 0x50 && buffer[i + 1] == 0x45 && buffer[i + 2] == 0 && buffer[i + 3] == 0)
                    {
                        return new DetectedMalwareInfo
                        {
                            FamilyName = "Potential IcedID / PhotoLoader",
                            Variant = "Headless PE",
                            Address = baseAddress,
                            Details = $"Missing MZ header, but valid NT header found at +0x{i:X}. Typical for IcedID payloads."
                        };
                    }
                }
            }

            return null;
        }

        private static T ByteArrayToStructure<T>(byte[] bytes) where T : struct
        {
            GCHandle handle = GCHandle.Alloc(bytes, GCHandleType.Pinned);
            try
            {
                return (T)Marshal.PtrToStructure(handle.AddrOfPinnedObject(), typeof(T));
            }
            finally
            {
                handle.Free();
            }
        }
    }
}