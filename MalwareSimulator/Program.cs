using System;
using System.Runtime.InteropServices;
using System.Threading;

namespace MalwareSimulator
{
    class Program
    {
        // P/Invoke Definitionen
        [DllImport("kernel32.dll", SetLastError = true)]
        static extern IntPtr VirtualAlloc(IntPtr lpAddress, UIntPtr dwSize, uint flAllocationType, uint flProtect);

        [DllImport("kernel32.dll", SetLastError = true)]
        static extern IntPtr LoadLibrary(string lpFileName);

        [DllImport("kernel32.dll", SetLastError = true)]
        static extern IntPtr GetModuleHandle(string lpModuleName);

        [DllImport("kernel32.dll")]
        static extern bool VirtualProtect(IntPtr lpAddress, UIntPtr dwSize, uint flNewProtect, out uint lpflOldProtect);

        const uint MEM_COMMIT = 0x1000;
        const uint MEM_RESERVE = 0x2000;
        const uint PAGE_EXECUTE_READWRITE = 0x40;
        const uint PAGE_READWRITE = 0x04;

        static void Main(string[] args)
        {
            Console.Title = "NativeProcesses - Malware Simulator Target";
            Console.WriteLine("PID: " + System.Diagnostics.Process.GetCurrentProcess().Id);
            Console.WriteLine("--------------------------------------------------");
            Console.WriteLine("1. Simulate RWX Shellcode (NOP Sled + PEB Access)");
            Console.WriteLine("2. Simulate Header Stomping (Load DLL & Erase Header)");
            Console.WriteLine("3. Exit");
            Console.WriteLine("--------------------------------------------------");

            while (true)
            {
                var key = Console.ReadKey(true);
                if (key.Key == ConsoleKey.D1)
                {
                    SimulateRwxShellcode();
                }
                else if (key.Key == ConsoleKey.D2)
                {
                    SimulateHeaderStomping();
                }
                else if (key.Key == ConsoleKey.D3)
                {
                    break;
                }
            }
        }

        static void SimulateRwxShellcode()
        {
            Console.WriteLine("[*] Allocating RWX memory...");

            // 1. Speicher reservieren (RWX)
            IntPtr mem = VirtualAlloc(IntPtr.Zero, (UIntPtr)4096, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
            if (mem == IntPtr.Zero)
            {
                Console.WriteLine("[-] VirtualAlloc failed.");
                return;
            }

            Console.WriteLine($"[+] Memory allocated at 0x{mem.ToString("X")}");

            // 2. Shellcode Muster schreiben
            // Wir nutzen das Muster aus ShellcodeDetector.cs: 
            // NOP Sled (8x 0x90) + PEB Access (0x64, 0xA1...)

            byte[] shellcode = new byte[] {
                0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, // NOP Sled
                0x90, 0x90, 0x90, 0x90, // Mehr NOPs
                0x64, 0xA1, 0x30, 0x00, 0x00, 0x00, // MOV EAX, FS:[30h] (PEB Access Pattern)
                0xC3 // RET
            };

            Marshal.Copy(shellcode, 0, mem, shellcode.Length);
            Console.WriteLine("[+] Malicious patterns written to memory.");
            Console.WriteLine("[!] READY TO SCAN. Press any key to continue...");
        }

        static void SimulateHeaderStomping()
        {
            string dllName = "uxtheme.dll"; // Eine harmlose DLL
            Console.WriteLine($"[*] Loading {dllName}...");

            IntPtr hMod = LoadLibrary(dllName);
            if (hMod == IntPtr.Zero)
            {
                Console.WriteLine("[-] LoadLibrary failed.");
                return;
            }
            Console.WriteLine($"[+] Module loaded at 0x{hMod.ToString("X")}");

            // Header überschreiben
            Console.WriteLine("[*] Stomping 'MZ' header in memory...");

            // Schreibrechte holen
            if (VirtualProtect(hMod, (UIntPtr)4096, PAGE_READWRITE, out uint oldProtect))
            {
                // Die ersten 2 Bytes (MZ) mit 0 überschreiben
                byte[] zeros = new byte[2] { 0x00, 0x00 };
                Marshal.Copy(zeros, 0, hMod, 2);

                // Rechte zurücksetzen (optional, aber realistischer für Malware, die Spuren verwischt)
                VirtualProtect(hMod, (UIntPtr)4096, oldProtect, out _);

                Console.WriteLine("[+] Header Stomped! 'MZ' is gone.");
            }
            else
            {
                Console.WriteLine("[-] VirtualProtect failed.");
            }
        }
    }
}


/*
 Schritt 3: Der Test-Ablauf
So führst du den Test durch:

Starte den MalwareSimulator (als Administrator, um sicherzugehen, obwohl User-Mode auch reichen sollte).

Du siehst die PID in der Konsole.

Drücke 1 für Shellcode-Simulation. Er sagt dir: "Memory allocated at 0x...".

Drücke 2 für Header Stomping. Er lädt uxtheme.dll und löscht das "MZ".

Starte RemoteClient (deine UI).

Verbinde dich zum Server (falls getrennt) oder nutze MainForm direkt (falls du lokal startest).

Suche in der Prozessliste nach MalwareSimulator.exe.

Rechtsklick auf den Prozess -> "Scan for Hooks (IAT, Inline, Memory)...".

Erwartetes Ergebnis
Wenn unsere Implementierung (PeAnomalyScanner + ShellcodeDetector) korrekt ist, sollte sich ein DetailForm öffnen mit folgenden Einträgen:

Für RWX Shellcode:

Type: Malicious RWX Section

Details: Section '' is RWX and contains suspicious data: Shellcode Pattern Detected (PEB Access / GetPC / NopSled)

Severity: Critical

Für Header Stomping:

Type: Header Stomping

ModuleName: uxtheme.dll

Details: MZ signature missing in memory...

Severity: High 
  
  */